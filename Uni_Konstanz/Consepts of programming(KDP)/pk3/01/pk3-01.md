---
title: Programming 3
subtitle: (Wintersemester 2024/25)
author: TT-Prof. Dr. Emanuele D'Osualdo
institute: Universität Konstanz
date: 21 October 2024
---

Today
--------------------------------------------------------------------------------

  * Organisational matters
  * Recap on Functions in Maths
  * Demo & Inspiration



Organisational matters:
--------------------------------------------------------------------------------

Language: English!

>  If you feel there is a language barrier let me know

Important: You must register for "Concepts of Programming" *and*
         "Programming Course 3", even if there is only *one* exam for
         both courses!



Style of the course "Programming course 3"
--------------------------------------------------------------------------------


The word "Programming course"

  * "I can already program"

  * "Course doesn't sound that difficult"


Both probably not quite right!

  * We look at programming from its mathematical side!

  * Proofs (always formal!) are also required in the exercises.

  * Computer Science 3 does not have the reputation of being easy.


In fact:

  * Programming is very formal.  So there is no reason to be afraid of formulas.

  * We only do "easy" maths (see maths lectures)

  * We do very descriptive maths.
    (mostly even: executable maths)



Course material and procedure:

  * No slides!  Essentially plain text, lots of source code.

  * Hands-on coding.

  * Sample solutions of the exercise sheets are extended here!

  * Alternative solutions and their advantages and disadvantages
    are often discussed.

  * The discussed text files end up in Git.



Git
--------------------------------------------------------------------------------


  * A good place to start reading: Make your first git commit [1]

  * For quick reference: GitHub Git Cheat Sheet [2]

  * For detailed reading:

    $ man git

Get the group directory:

  * Create private fork [3]

  * Add emanuele.dosualdo and Tutor:in as maintainers

  * Set up a local copy:

    $ mkdir -p ~/unikram/inf3
    $ cd ~/unikram/inf3
    $ git clone \
      https://gitlab.inf.uni-konstanz.de/‹vorname.nachname›/info3-2024w.git .
    $ git remote add upstream \
      https://gitlab.inf.uni-konstanz.de/dbis/education/info3-2024w.git

Authentication with the university login data (or via SSH [2]).

Update:

    $ cd ~/unikram/inf3
    $ git fetch --all
    $ git pull                  # für Updates vom Fork der Gruppe
    $ git pull upstream master  # für Updates vom öffentlichen Repo


____________________
[1] https://gitlab.inf.uni-konstanz.de/help/tutorials/make_your_first_git_commit.md
[2] https://training.github.com/downloads/de/github-git-cheat-sheet/
[3] https://gitlab.inf.uni-konstanz.de/dbis/education/info3-2024w/-/forks/new
[4] https://gitlab.inf.uni-konstanz.de/help/user/ssh.md
    Im Fall von Authentifizierung per SSH muss
    `https://gitlab.inf.uni-konstanz.de/` durch
    `git@gitlab.inf.uni-konstanz.de:` ersetzt werden.



Your solutions
--------------------------------------------------------------------------------


Each group creates a fork
`https://gitlab.inf.uni-konstanz.de/‹vorname.nachname›/info3-2024w.git`.
The submissions must be checked in by the deadline.


  * Create a directory for each exercise sheet:

      - for example: 01, 02, ...

      - It should be clearly recognisable what belongs to which task.

  * Accepted formats for programming tasks:

      text/plain; charset=utf-8
      text/plain; charset=us-ascii

  * Accepted formats for theoretical tasks:

    - text/plain; charset=utf-8
    - text/plain; charset=us-ascii

    - .tex files, i.e. the source code for LaTeX documents.  
      Not the generated PDF!
      These must be able to be translated by the
      translate them without additional installed packages. 

  * Submitted files should be significantly smaller than 64kB.

  * Avoid tabs in the text files!

The text/plain formats have the advantage that you can directly apply `git diff` to them
and see what has changed.



The tutors will assess your submissions and check in corrections.
You can track changes with Git.

  ⇒ Don't worry: if in doubt, your original can be restored at any time!

ATTENTION! From the 2nd exercise sheet onwards,
programming tasks that are not accepted by the compiler
are considered as *not submitted*!


Comments
--------------------------------------------------------------------------------


  * Good comments do not describe what the code *does*,

        // fictional imperative Code (maybe C, or similar)
        x += 508;  // increment x by 508

    but *why* it does what it does:

        x += 508;  // Done with this item, go to next.  Block size
                   // is 512, and we have moved array index by 4 already.


  * Documentation is *always* part of the job.

      - Is taken into account in the evaluation!

      - Can save you if the solution is wrong after all.

      - Poor documentation is *not* better than none at all.



Editors
--------------------------------------------------------------------------------


### Simple Editors

  * Linux: leafpad, nano, Sublime Text

  * Windows: Notepad++, Sublime Text

  * macOS: Sublime Text

Small, weak, but simple and fast.  They are sufficient, easy to
and are often included with the operating system.


### Visual Studio Code

  * Available for Windows, macOS, Linux [7]

  * IDE-like

  * Multiple Haskell integrations of varying complexity

      - „Haskell Syntax Highlighting“ (nur Highlighting)

      - „Haskell for Visual Studio Code“ (editor's choice)
        https://marketplace.visualstudio.com/items?itemName=haskell.haskell

      - „Simple GHC (Haskell) Integration“

      - More complex, more IDE-like: "Haskelly", "Haskero"
        (more configuration, subsequent installation of additional tools, ...)


### Emacs

  * Freely available [3].

  * Included with many Linux distros.

  * Haskell mode for Emacs [4].

      - syntax highlighting
      - intelligent indentation


NOTE: Submit solutions either as pure ASCII or as UTF-8.
      Make sure that the editor can do this.


Alternatives

  * There are heaps of small and large tools that make parts of the work with
    Haskell easier.

  * None of them are necessary for this course!
    Our "projects" are too small to make use of this.

____________________
[3] http://www.gnu.org/software/emacs/emacs.html
[4] http://www.haskell.org/haskellwiki/Emacs
[7] https://code.visualstudio.com/


What is a function, mathematically
--------------------------------------------------------------------------------


Good and useful reading are e.g. the first four chapters of the MGI script
by Sven Kosub (e.g. available from WS 13/14 [6]).


Def: Let A, B be sets.  Then

    A × B := { (a,b) | a ∈ A ∧ b ∈ B }

the "cross product of A and B", the elements (a,b) are called "pairs over A and B".


Pairs are ordered, i.e,

      (a,b) = (c,d)
    ⇔
      a = c ∧ b = d


Def: Relation

    A subset of a cross product, i.e. a set

        R ⊆ A × B

    is called "binary relation" on A × B.


Notation: Write often

    x R y

instead of

    (x,y) ∈ R
.


Example: The "less than" relation

    `<` ⊆ ℕ × ℕ

could be defined as follows:

    `<` := { (a,b) | a ∈ ℕ
                   ∧ b ∈ ℕ
                   ∧ ∃k. k ∈ ℕ ∧ k ≠ 0 ∧ a + k = b
           }

or something like this:

    `<` := { (a,b) | (a,b) ∈ ℕ×ℕ  ∧  b-a-1 ∈ ℕ }


Try it out:

  Let A = { 1, 2, 3 } and B = { 1, 2, 3 }, 
  then their cross product is:

    A × B = { (1,1), (1,2), (1,3), (2,1), (2,2), (2,3) 
              (3,1), (3,2), (3,3) }

    < ⊆ A × B    since  < = { (1,2), (1,3), (2,3) }

    (1, 3) ∈ <   which nobody would write like this,
    1 < 3        but like this.


Def: (Partial) function

  A relation R ⊆ A × B with the property

      ∀x y z. ( x R y  ∧  x R z  ⇒  y = z )

  means "function from A to B".

  A function is *total* if

      ∀x. ∃y. x R y



Notation: we write

    f :: A -> B

to mean

    f ⊆ A × B is a function.

The idea behind it:
  The first element of the pair (the "argument") determines the second!

  In a total function `f :: A -> B`,
  for every `x ∈ A` there exists a *unique* `y ∈ B` such that `(x,y) ∈ f`.


Since the second element of the pair is determined by the first,
we often write

    f(x) = y or without brackets: f x = y

instead of

    (x,y) ∈ f
.

In certain cases we care about whether the function is total or not.
In such cases, the only thing that can go wrong is for some `x ∈ A`
not to have any `y ∈ B` such that `(x,y) ∈ f`, in which case we write

    f(x) = ⊥

to indicate the result of applying the function to the argument `x`
is undefined.
This would never happen for total functions.




Example:

      f := { (x,y) | y = x * x } is a function (without proof)

What is f(3) then?

    y = f(3)

  ≡ -- Notation!

    (3,y) ∈ f

  ≡ -- Definition of f

    (3,y) ∈ { (x,y) | y = x * x }
  ⇒
    (3,y) ∈ { (3,y) | y = 3 * 3 }
  ⇒
    (3,y) ∈ { (3,y) | y = 9 }
  ⇒
    (3,y) ∈ { (3,9) }
  ⇒
    y = 9



Example:

      `<` is not a function.

Why not?


























      3 < 9
      3 < 7


____________________
[6] Sven Kosub.  Skriptum Mathematische Grundlagen der Informatik.
    https://www.toc.uni-konstanz.de/lehre/wintersemester-2013-14/mathematische-grundlagen-der-informatik-ws-2013-14/


======================================================================
