# SOL 05

# Ex01

F : {0, 1}^n × {0, 1} ^ n → {0, 1} ^ (ℓ(n))
F': {0, 1}^n × {0, 1} ^ (n - 1) → {0, 1} ^ (2 * ℓ(n))

(a) F'_k(x) := Fk(0||x) || Fk(0||x)

which ever x we decide to pick, right and left sides of F'_k(x) will be the same, so it's not a PRG

(b) F′_k(x) := Fk(0||x) || Fk(x||0).

if x = 0^(n-1), than again we get two same sides of function F'k


# Ex02

F : {0, 1} ^ n × {0, 1} ^ n → {0, 1} ^ n

c := Fk(0^n) ⊕ m.
m := Fk(0^n) ⊕ c

(a) EAV-secutiry for multiple encryptions:

m0,m1 ∈ {0,1}^n

c0 = Fk(0^n) ⊕ m0
c1 = Fk(0^n) ⊕ m1

c0 ⊕ c1 = (Fk(0^n) ⊕ m0) ⊕ (Fk(0^n) ⊕ m1) = m0 ⊕ m1

(b) CPA-Secutiry 

same idea like in (a)

(c) CPA-security for multiple enctyptions

same idea like in (a)

(d) CPA-security for multiple encryptions, with the additional requirement that the adversary can never query a message twice.

same idea like in (a), iditionally m0!=m1

# Ex03

|k| = 256 bit

|m_n| = 128 bit (one block)

|M| = 1024 (message length)

in CBC-mode |k| = |m_b| = |IV| = 128

then |IV| + |M| = 128 + 1024 = 1152

# Ex04

Prove that chained CBC mode is not CPA-secure.


If adversary A encrypts m0 = m1, then with last block of m0, we can determine which message was encrytped. Because IV = m0_n, then encryption will be predictable